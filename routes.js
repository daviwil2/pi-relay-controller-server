// ./routes/routes.js

'use strict';

module.exports = exports = function(app, config, log){

  var _       = require('lodash');
  var express = require('express');
  var gpio    = require('./lib/gpio.js');

  // use an undocumented setting for express.js to set the formatting of stringified json so the /status path is formatted in a more readable style
  app.set('json spaces', 4);

  /// helper functions

  console.log('setting GPIO_1 as out');
  gpio.setup(gpio.PIN.GPIO_1, gpio.DIRECTION.OUT);
  console.log('writing 1 to GPIO_1');
  gpio.write(gpio.PIN.GPIO_1, 1); // write value to GPIO_1 (pin #12, CPIO#238)
  console.log('unexporting GPIO_1');
  gpio.unset(gpio.PIN.GPIO_0); // unexport GPIO_0 (pin #11)

  /*
  var pin;
  var pins = [12, 13, 15, 16, 22, 7, 24,26, 19, 21, 23, 29, 31, 33, 35, 32, 36];
  pins.forEach(pin => {

    gpio.open(pin, 'output', function(err){
      if (err){
        console.log(pin, err)
      } else {
        gpio.write(pin, 0, function(){ gpio.close(pin) });
      }; // if
    });

  });
  */

  /*
  // create an array with an object for each relay, {number, state, gpio)
  var relays = [];
  let defaultState = (config.gpio.default == 'NC') ? 'closed' : 'open' ; // define default state
  _.forOwn(config.gpio.relays, (obj, key)=>{
    // console.log('value', value, 'key', key) // value = obj, key = 1-4
    obj.state = defaultState; // set default state attribute
    console.log(obj.pin)
    try {
      obj.gpio = new gpio(obj.pin, 'out'); // create gpio instance so we can interact with the relay via the gpio pin
    } catch (err){
      console.log(err);
    };
    relays.push(obj);
  }); // _.forOwn

  log.trace(relays.length.toString()+' relays defined as \'out\' and set to state 0');
  */

  /// express routes

  // home
  app.get('/', function(req, res, next){
    res.status(200).json({status: "ok"})
  }); // app.get

  // relays
  // returns array of available relays with their state
  app.get('/relays', function(req, res, next){
    let array = [];
    // _.each(relays, (value) => { array.push(_relayState(value)) });
    res.status(200).json({relays: array})
  }); // app.get

  /*
  // TODO: add handlers for the various paths... /kitchen/image.jpg etc.
  app.get('/:stream', function(req, res, next){

    let streamName = req.params.stream;
    if (streams.indexOf(streamName) !== -1){

      log.trace('received request for image from stream \''+streamName+'\'');

      let haveFrame = false; // set boolean flag as we don't yet have a flag to process

      // get the uri to the stream, use settings or defaults, and intantiate the stream
      let uri = (config.streams[streamName]);
      let resolution = (config.ffmpeg && config.ffmpeg.resolution) ? config.ffmpeg.resolution : "1920x1080" ; // native resolutions are 1920x1080, 1024x576 or 640x360
      let quality = (config.ffmpeg && config.ffmpeg.quality) ? Number(config.ffmpeg.quality) : 5 ;
      log.trace('for stream \''+streamName+'\', connecting to uri \''+uri+'\' at resolution \''+resolution+'\' with quality '+quality.toString());
      let stream = new rtsp.FFMpeg({input: uri, resolution: resolution, quality: quality});

      /// handlers for events generated by the stream emitter

      stream.on('start', () => {
			  log.trace('start event received for stream \''+streamName+'\'');
      }); // start

      stream.on('data', function(chunk){

        // if we don't yet have a frame to process then proceed...
        if(haveFrame == false){

          function _formatNumber(value) {
            return value.toString().replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",");
          }; // _formatNumber

          log.trace('frame received, length '+_formatNumber(chunk.length)+' bytes');
          haveFrame = true; // set flag to prevent processing of another frame
          res.type('jpeg'); // set the type to 'jpeg' which in turn sets the Content-Type header
          res.status(200).send(Buffer.from(chunk)); // return the image to the Homey client, converting it to a Buffer first
          log.trace('frame sent, exiting event handler');
          stream = null;

        }; // if

      }); // data

    } else {
      res.status(404).send('camera not found');
    }; // if
  }); // app.get
  */

  /// error messages, need to be replaced with handlebars-rendered pages that can be displayed in the main region

  // 404 path not found
  app.use(function(req, res, next) {
    log.error('404 error: '+req.path);
    res.status(404);
    res.render('404');
  }); // app.use

  // 500 internal server error
  app.use(function(err, req, res, next) {

    // from the V8 stack extract the location of the error
    var where = err.stack.split(/\r?\n/)[1].trim();
    var array = where.split(/:/);
    where = array[0].split(' ')[1].trim()+' line '+array[1]+' character '+array[2];

    log.error('500 error: '+err.message+' in '+where);
    res.status(500);
    res.render('500', {
      err: err
    }); // res.render

  }); // app.use

} // module.exports
